// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.8.4

package models

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	casbinRuleFieldNames          = builder.RawFieldNames(&CasbinRule{})
	casbinRuleRows                = strings.Join(casbinRuleFieldNames, ",")
	casbinRuleRowsExpectAutoSet   = strings.Join(stringx.Remove(casbinRuleFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	casbinRuleRowsWithPlaceHolder = strings.Join(stringx.Remove(casbinRuleFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"

	cacheCasbinRuleIdPrefix                = "cache:casbinRule:id:"
	cacheCasbinRulePtypeV0V1V2V3V4V5Prefix = "cache:casbinRule:ptype:v0:v1:v2:v3:v4:v5:"
)

type (
	casbinRuleModel interface {
		Insert(ctx context.Context, data *CasbinRule) (sql.Result, error)
		FindOne(ctx context.Context, id uint64) (*CasbinRule, error)
		FindOneByPtypeV0V1V2V3V4V5(ctx context.Context, ptype sql.NullString, v0 sql.NullString, v1 sql.NullString, v2 sql.NullString, v3 sql.NullString, v4 sql.NullString, v5 sql.NullString) (*CasbinRule, error)
		Update(ctx context.Context, data *CasbinRule) error
		Delete(ctx context.Context, id uint64) error
	}

	defaultCasbinRuleModel struct {
		sqlc.CachedConn
		table string
	}

	CasbinRule struct {
		Id    uint64         `db:"id"`
		Ptype sql.NullString `db:"ptype"`
		V0    sql.NullString `db:"v0"`
		V1    sql.NullString `db:"v1"`
		V2    sql.NullString `db:"v2"`
		V3    sql.NullString `db:"v3"`
		V4    sql.NullString `db:"v4"`
		V5    sql.NullString `db:"v5"`
	}
)

func newCasbinRuleModel(conn sqlx.SqlConn, c cache.CacheConf, opts ...cache.Option) *defaultCasbinRuleModel {
	return &defaultCasbinRuleModel{
		CachedConn: sqlc.NewConn(conn, c, opts...),
		table:      "`casbin_rule`",
	}
}

func (m *defaultCasbinRuleModel) Delete(ctx context.Context, id uint64) error {
	data, err := m.FindOne(ctx, id)
	if err != nil {
		return err
	}

	casbinRuleIdKey := fmt.Sprintf("%s%v", cacheCasbinRuleIdPrefix, id)
	casbinRulePtypeV0V1V2V3V4V5Key := fmt.Sprintf("%s%v:%v:%v:%v:%v:%v:%v", cacheCasbinRulePtypeV0V1V2V3V4V5Prefix, data.Ptype, data.V0, data.V1, data.V2, data.V3, data.V4, data.V5)
	_, err = m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("delete from %s where `id` = ?", m.table)
		return conn.ExecCtx(ctx, query, id)
	}, casbinRuleIdKey, casbinRulePtypeV0V1V2V3V4V5Key)
	return err
}

func (m *defaultCasbinRuleModel) FindOne(ctx context.Context, id uint64) (*CasbinRule, error) {
	casbinRuleIdKey := fmt.Sprintf("%s%v", cacheCasbinRuleIdPrefix, id)
	var resp CasbinRule
	err := m.QueryRowCtx(ctx, &resp, casbinRuleIdKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", casbinRuleRows, m.table)
		return conn.QueryRowCtx(ctx, v, query, id)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultCasbinRuleModel) FindOneByPtypeV0V1V2V3V4V5(ctx context.Context, ptype sql.NullString, v0 sql.NullString, v1 sql.NullString, v2 sql.NullString, v3 sql.NullString, v4 sql.NullString, v5 sql.NullString) (*CasbinRule, error) {
	casbinRulePtypeV0V1V2V3V4V5Key := fmt.Sprintf("%s%v:%v:%v:%v:%v:%v:%v", cacheCasbinRulePtypeV0V1V2V3V4V5Prefix, ptype, v0, v1, v2, v3, v4, v5)
	var resp CasbinRule
	err := m.QueryRowIndexCtx(ctx, &resp, casbinRulePtypeV0V1V2V3V4V5Key, m.formatPrimary, func(ctx context.Context, conn sqlx.SqlConn, v any) (i any, e error) {
		query := fmt.Sprintf("select %s from %s where `ptype` = ? and `v0` = ? and `v1` = ? and `v2` = ? and `v3` = ? and `v4` = ? and `v5` = ? limit 1", casbinRuleRows, m.table)
		if err := conn.QueryRowCtx(ctx, &resp, query, ptype, v0, v1, v2, v3, v4, v5); err != nil {
			return nil, err
		}
		return resp.Id, nil
	}, m.queryPrimary)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultCasbinRuleModel) Insert(ctx context.Context, data *CasbinRule) (sql.Result, error) {
	casbinRuleIdKey := fmt.Sprintf("%s%v", cacheCasbinRuleIdPrefix, data.Id)
	casbinRulePtypeV0V1V2V3V4V5Key := fmt.Sprintf("%s%v:%v:%v:%v:%v:%v:%v", cacheCasbinRulePtypeV0V1V2V3V4V5Prefix, data.Ptype, data.V0, data.V1, data.V2, data.V3, data.V4, data.V5)
	ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?)", m.table, casbinRuleRowsExpectAutoSet)
		return conn.ExecCtx(ctx, query, data.Ptype, data.V0, data.V1, data.V2, data.V3, data.V4, data.V5)
	}, casbinRuleIdKey, casbinRulePtypeV0V1V2V3V4V5Key)
	return ret, err
}

func (m *defaultCasbinRuleModel) Update(ctx context.Context, newData *CasbinRule) error {
	data, err := m.FindOne(ctx, newData.Id)
	if err != nil {
		return err
	}

	casbinRuleIdKey := fmt.Sprintf("%s%v", cacheCasbinRuleIdPrefix, data.Id)
	casbinRulePtypeV0V1V2V3V4V5Key := fmt.Sprintf("%s%v:%v:%v:%v:%v:%v:%v", cacheCasbinRulePtypeV0V1V2V3V4V5Prefix, data.Ptype, data.V0, data.V1, data.V2, data.V3, data.V4, data.V5)
	_, err = m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, casbinRuleRowsWithPlaceHolder)
		return conn.ExecCtx(ctx, query, newData.Ptype, newData.V0, newData.V1, newData.V2, newData.V3, newData.V4, newData.V5, newData.Id)
	}, casbinRuleIdKey, casbinRulePtypeV0V1V2V3V4V5Key)
	return err
}

func (m *defaultCasbinRuleModel) formatPrimary(primary any) string {
	return fmt.Sprintf("%s%v", cacheCasbinRuleIdPrefix, primary)
}

func (m *defaultCasbinRuleModel) queryPrimary(ctx context.Context, conn sqlx.SqlConn, v, primary any) error {
	query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", casbinRuleRows, m.table)
	return conn.QueryRowCtx(ctx, v, query, primary)
}

func (m *defaultCasbinRuleModel) tableName() string {
	return m.table
}
