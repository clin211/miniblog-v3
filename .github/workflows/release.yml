name: Release CI/CD Pipeline

on:
  push:
    branches:
      - release
  workflow_dispatch:
    inputs:
      environment:
        description: '部署环境'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  # 本地构建的镜像标签
  IMAGE_TAG: release

jobs:
  # 代码质量检查
  code-quality:
    name: 代码质量检查
    runs-on: ubuntu-latest

    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置 Go 环境
        uses: actions/setup-go@v4
        with:
          go-version: '1.24.2'
          cache: true

      - name: 运行代码检查
        run: |
          echo "运行 go mod tidy..."
          go mod tidy

          echo "运行 go vet..."
          go vet ./...

          echo "运行 go fmt 检查..."
          if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
            echo "代码格式不正确，请运行 go fmt ./..."
            gofmt -s -l .
            exit 1
          fi

          echo "代码质量检查通过"

  # 构建 Docker 镜像
  build:
    name: 构建镜像
    needs: code-quality
    runs-on: ubuntu-latest

    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置 Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 构建 user-api 镜像
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./deploy/prod/Dockerfile.user-api
          push: false
          load: true
          tags: miniblog-v3-user-api:release
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: 构建 user-rpc 镜像
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./deploy/prod/Dockerfile.user-rpc
          push: false
          load: true
          tags: miniblog-v3-user-rpc:release
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: 保存镜像为 tar 文件
        run: |
          docker save miniblog-v3-user-api:release -o miniblog-v3-user-api.tar
          docker save miniblog-v3-user-rpc:release -o miniblog-v3-user-rpc.tar

      - name: 上传镜像为 artifacts
        uses: actions/upload-artifact@v4
        with:
          name: docker-images
          path: |
            miniblog-v3-user-api.tar
            miniblog-v3-user-rpc.tar
          retention-days: 1

      - name: 输出镜像信息
        run: |
          echo "User API 镜像: miniblog-v3-user-api:release"
          echo "User RPC 镜像: miniblog-v3-user-rpc:release"
          ls -la *.tar

  # 部署到服务器
  deploy:
    name: 部署到服务器
    needs: build
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 下载构建的镜像
        uses: actions/download-artifact@v4
        with:
          name: docker-images
          path: ./images

      - name: 上传部署文件
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "deploy/prod/*"
          target: "/home/project/miniblog-v3/"
          strip_components: 1

      - name: 上传 Docker 镜像
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "images/*.tar"
          target: "/home/project/miniblog-v3/"

      - name: 创建部署目录结构
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            mkdir -p /home/project/miniblog-v3/logs

      - name: 设置文件权限
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd /home/project/miniblog-v3
            chmod +x deploy.sh
            chmod +x infrastructure-manager.sh
            chmod +x kafka-manager.sh
            chmod +x nginx-manager.sh
            chmod +x health-check.sh

      - name: 设置镜像标签
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd /home/project/miniblog-v3
            # 设置镜像标签为 release（用于应用服务）
            echo "IMAGE_TAG=release" > .env

      - name: 加载 Docker 镜像
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd /home/project/miniblog-v3
            docker load -i miniblog-v3-user-api.tar
            docker load -i miniblog-v3-user-rpc.tar
            docker images | grep miniblog

      - name: 检查基础设施服务状态
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd /home/project/miniblog-v3

            echo "检查基础设施服务状态..."
            ./infrastructure-manager.sh status

            echo ""
            echo "执行健康检查..."

            # 使用健康检查脚本进行快速检查
            if ./infrastructure-manager.sh health quick; then
              echo "✅ 所有基础设施服务运行正常"
            else
              echo "❌ 基础设施服务存在问题，请手动启动基础设施服务"
              echo "执行命令: ./infrastructure-manager.sh start"
              echo ""
              echo "详细健康检查报告："
              ./infrastructure-manager.sh health all
              exit 1
            fi

      - name: 启动应用服务
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd /home/project/miniblog-v3

            echo "检查网络连接..."
            docker network ls | grep miniblog-v3-network || echo "网络不存在"

            echo "检查基础设施服务容器..."
            docker ps | grep miniblog-v3- || echo "没有找到基础设施服务容器"

            echo "检查镜像是否存在..."
            docker images | grep miniblog-v3-user || echo "没有找到应用镜像"

            echo "停止现有应用服务..."
            docker-compose down user-api user-rpc 2>/dev/null || true

            echo "启动应用服务..."
            docker-compose up -d user-api user-rpc

            echo "等待应用服务启动..."
            sleep 30

            echo "检查应用服务状态..."
            docker-compose ps user-api user-rpc

            echo "检查应用服务日志..."
            echo "=== User RPC 日志 ==="
            docker-compose logs --tail 20 user-rpc
            echo "=== User API 日志 ==="
            docker-compose logs --tail 20 user-api

            echo "检查容器是否正在运行..."
            docker ps | grep miniblog-user || echo "应用容器未运行"



      - name: 清理临时文件
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd /home/project/miniblog-v3
            rm -f miniblog-v3-*.tar

  # 通知部署结果
  notify:
    name: 部署通知
    needs: [deploy]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: 部署成功通知
        if: needs.deploy.result == 'success'
        run: |
          echo "✅ 部署成功！"
          echo "服务地址: http://${{ secrets.SERVER_HOST }}"
          echo "User API: http://${{ secrets.SERVER_HOST }}:8888"
          echo "User RPC: http://${{ secrets.SERVER_HOST }}:8080"
          echo ""
          echo "基础设施服务："
          echo "  - MySQL: ${{ secrets.SERVER_HOST }}:3306"
          echo "  - Redis: ${{ secrets.SERVER_HOST }}:6379"
          echo "  - etcd: ${{ secrets.SERVER_HOST }}:2379"
          echo "  - Kafka: ${{ secrets.SERVER_HOST }}:29092"
          echo ""
          echo "下一步操作："
          echo "  1. 检查服务状态: ./infrastructure-manager.sh status"
          echo "  2. 配置外部 nginx: ./nginx-manager.sh install"
          echo "  3. 创建 Kafka 主题: ./kafka-manager.sh create-default"

      - name: 部署失败通知
        if: needs.deploy.result == 'failure'
        run: |
          echo "❌ 部署失败！"
          echo "请检查部署日志以获取详细信息"
