# 10 中间件设计

## 概述

在微服务架构中，中间件是处理横切关注点（Cross-cutting Concerns）的重要组件。本章将详细介绍认证中间件的设计和实现，该中间件支持HTTP和gRPC两种协议，用于验证用户身份并提取用户信息。

## 设计目标

1. **统一认证机制**：为HTTP API和gRPC服务提供统一的JWT认证机制
2. **用户信息传递**：将解析出的用户ID安全地传递到业务逻辑层
3. **错误处理**：提供统一的认证失败响应格式
4. **易于集成**：支持go-zero框架的中间件规范，便于集成到现有项目中

## 架构设计

### 核心组件

```tree
pkg/middleware/
├── authn.go          # 认证中间件核心实现
└── authn_test.go     # 中间件测试文件
```

### 中间件类型

1. **HTTP中间件**：用于REST API的认证
2. **gRPC拦截器**：用于gRPC服务的认证
3. **结构体中间件**：符合go-zero框架规范的中间件实现

## 实现细节

### 1. 中间件结构体设计

按照go-zero官方文档规范，我们设计了结构体中间件：

```go
// AuthnMiddleware 认证中间件结构体
type AuthnMiddleware struct {
}

// NewAuthnMiddleware 创建认证中间件实例
func NewAuthnMiddleware() *AuthnMiddleware {
    return &AuthnMiddleware{}
}

// Handle HTTP认证中间件处理方法
func (m *AuthnMiddleware) Handle(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // 解析JWT token
        claims, err := token.ParseRequest(r)
        if err != nil {
            response.WriteResponse(r.Context(), w, errorx.ErrTokenInvalid)
            return
        }

        // 将用户ID存储到上下文中
        ctx := context.WithValue(r.Context(), known.XUserID, claims.UserID)
        next.ServeHTTP(w, r.WithContext(ctx))
    }
}
```

### 2. gRPC拦截器设计

```go
// AuthnInterceptor gRPC认证拦截器
func AuthnInterceptor() grpc.UnaryServerInterceptor {
    return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
        // 定义不需要认证的方法
        noAuthMethods := map[string]bool{
            "/rpc.User/Login":    true,
            "/rpc.User/Register": true,
        }

        // 检查当前方法是否需要认证
        if noAuthMethods[info.FullMethod] {
            // 不需要认证的方法直接执行
            return handler(ctx, req)
        }

        // 需要认证的方法解析JWT token
        claims, err := token.ParseRequest(ctx)
        if err != nil {
            return nil, status.Errorf(codes.Unauthenticated, "invalid auth token: %v", err)
        }

        // 将用户ID存储到上下文中
        ctx = context.WithValue(ctx, known.XUserID, claims.UserID)
        return handler(ctx, req)
    }
}
```

### 3. 中间件职责

中间件的主要职责是：

1. **Token验证**：验证请求中的JWT token是否有效
2. **用户信息传递**：将解析出的用户ID存储到上下文中
3. **错误处理**：对无效token返回统一的错误响应

用户ID的获取可以直接使用`token.ParseRequest`方法，无需额外的工具函数。

## 集成方式

### 1. HTTP API集成

#### 更新ServiceContext

```go
type ServiceContext struct {
    Config         config.Config
    UserRpc        rpc.UserClient
    AuthnMiddleware rest.Middleware
}

func NewServiceContext(c config.Config) *ServiceContext {
    return &ServiceContext{
        Config:         c,
        UserRpc:        rpc.NewUserClient(zrpc.MustNewClient(c.UserRpc).Conn()),
        AuthnMiddleware: middleware.NewAuthnMiddleware().Handle,
    }
}
```

#### 路由配置

```go
func RegisterHandlers(server *rest.Server, serverCtx *svc.ServiceContext) {
    // 需要认证的路由组
    server.AddRoutes(
        rest.WithMiddlewares(
            []rest.Middleware{serverCtx.AuthnMiddleware},
            []rest.Route{
                {
                    Method:  http.MethodGet,
                    Path:    "/user/:userId",
                    Handler: GetUserHandler(serverCtx),
                },
                {
                    Method:  http.MethodPut,
                    Path:    "/user/:userId",
                    Handler: UpdateUserHandler(serverCtx),
                },
                {
                    Method:  http.MethodDelete,
                    Path:    "/user/:userId",
                    Handler: DeleteUserHandler(serverCtx),
                },
            }...,
        ),
    )

    // 不需要认证的路由组
    server.AddRoutes(
        []rest.Route{
            {
                Method:  http.MethodPost,
                Path:    "/user/login",
                Handler: LoginHandler(serverCtx),
            },
            {
                Method:  http.MethodPost,
                Path:    "/user/register",
                Handler: RegisterHandler(serverCtx),
            },
        },
    )
}
```

### 2. gRPC服务集成

```go
func main() {
    // ... 配置加载等代码 ...

    s := zrpc.MustNewServer(c.RpcServerConf, func(grpcServer *grpc.Server) {
        rpc.RegisterUserServer(grpcServer, server.NewUserServer(ctx))
        if c.Mode == service.DevMode || c.Mode == service.TestMode {
            reflection.Register(grpcServer)
        }
    })
    defer s.Stop()

    // 添加gRPC拦截器
    s.AddUnaryInterceptors(middleware.AuthnInterceptor())

    fmt.Printf("Starting rpc server at %s...\n", c.ListenOn)
    s.Start()
}
```

## 认证策略

### 1. 需要认证的接口

- **获取用户信息** (`GET /user/:userId`)
- **更新用户信息** (`PUT /user/:userId`)
- **删除用户** (`DELETE /user/:userId`)
- **gRPC GetUser** (`/rpc.User/GetUser`)
- **gRPC UpdateUser** (`/rpc.User/UpdateUser`)
- **gRPC DeleteUser** (`/rpc.User/DeleteUser`)

### 2. 不需要认证的接口

- **用户登录** (`POST /user/login`)
- **用户注册** (`POST /user/register`)
- **gRPC Login** (`/rpc.User/Login`)
- **gRPC Register** (`/rpc.User/Register`)

### 3. 认证流程

1. **HTTP API**：通过路由分组控制，需要认证的路由组应用`AuthnMiddleware`
2. **gRPC服务**：通过方法名判断，在`AuthnInterceptor`中定义白名单

## 使用示例

### 1. 在Logic层获取用户ID

```go
func (l *GetUserLogic) GetUser(req *types.GetUserRequest) (resp *types.GetUserResponse, err error) {
    // 直接使用token.ParseRequest获取用户信息
    claims, err := token.ParseRequest(l.ctx)
    if err != nil {
        return nil, errorx.ErrUnauthorized
    }

    // 验证用户权限（只能查看自己的信息）
    if claims.UserID != req.UserId {
        return nil, errorx.ErrUnauthorized
    }

    // 业务逻辑处理
    // ...
}
```

### 2. 在gRPC Logic层获取用户ID

```go
func (l *GetUserLogic) GetUser(in *rpc.GetUserRequest) (*rpc.GetUserResponse, error) {
    // 直接使用token.ParseRequest获取用户信息
    claims, err := token.ParseRequest(l.ctx)
    if err != nil {
        return nil, status.Errorf(codes.Unauthenticated, "user not authenticated")
    }

    // 业务逻辑处理
    // ...
}
```

## 错误处理

### 1. HTTP错误响应

当认证失败时，中间件会返回统一的错误响应：

```json
{
    "code": 401002,
    "message": "Token was invalid.",
    "data": null,
    "reason": ""
}
```

### 2. gRPC错误响应

gRPC服务会返回标准的gRPC错误，通过`errorx.ToGRPCError()`进行转换：

```go
// 错误转换工具
func ToGRPCError(err error) error {
    if err == nil {
        return nil
    }

    // 检查是否是 errorx 错误
    if e, ok := err.(*Errno); ok {
        return status.Error(getGRPCCode(e.Code), e.Message)
    }

    // 如果不是 errorx 错误，返回内部错误
    return status.Error(codes.Internal, err.Error())
}
```

#### 错误码映射

| errorx错误码 | gRPC错误码 | 说明 |
|-------------|-----------|------|
| 400001, 400002 | InvalidArgument | 参数错误 |
| 401001, 401002, 401003, 401103 | Unauthenticated | 认证失败 |
| 403104 | PermissionDenied | 权限不足 |
| 404001, 404102 | NotFound | 资源不存在 |
| 409101 | AlreadyExists | 资源已存在 |
| 500001 | Internal | 内部错误 |

#### 使用示例

```go
// 在RPC逻辑中使用
if err := l.validateRequest(req); err != nil {
    return nil, errorx.ToGRPCError(err)
}

// 错误会被正确转换为gRPC错误码
// 例如："手机号已存在" -> codes.AlreadyExists
```

### 3. API层错误处理

API层使用统一的`response.WriteResponse`处理响应，并通过`errorx.FromGRPCError()`将gRPC错误转换为errorx错误：

```go
// gRPC错误到errorx错误转换工具
func FromGRPCError(err error) error {
    if err == nil {
        return nil
    }

    // 检查是否是 gRPC 错误
    st, ok := status.FromError(err)
    if !ok {
        return InternalServerError.SetMessage("%s", err.Error())
    }

    // 根据 gRPC 错误码转换为 errorx 错误
    switch st.Code() {
    case codes.AlreadyExists:
        return ErrUserAlreadyExists.SetMessage("%s", st.Message())
    // ... 其他错误码映射
    }
}
```

#### API Handler统一响应处理

```go
func RegisterHandler(svcCtx *svc.ServiceContext) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        var req types.RegisterRequest
        if err := httpx.Parse(r, &req); err != nil {
            response.WriteResponse(r.Context(), w, err)
            return
        }

        l := logic.NewRegisterLogic(r.Context(), svcCtx)
        resp, err := l.Register(&req)
        if err != nil {
            response.WriteResponse(r.Context(), w, err)
        } else {
            response.WriteResponse(r.Context(), w, resp)
        }
    }
}
```

#### 响应格式

**成功响应**：
```json
{
    "code": 0,
    "message": "ok",
    "data": {
        "userId": "user_123"
    },
    "reason": ""
}
```

**错误响应**：
```json
{
    "code": 409101,
    "message": "手机号已存在",
    "data": null,
    "reason": ""
}
```

## 安全考虑

1. **Token验证**：使用JWT标准验证token的有效性
2. **上下文传递**：通过context安全地传递用户信息
3. **错误信息**：避免在错误响应中泄露敏感信息
4. **权限验证**：在业务逻辑层进行细粒度的权限控制

## 测试策略

### 1. 单元测试

- 测试有效token的解析
- 测试无效token的错误处理
- 测试缺少Authorization头的处理
- 测试用户ID的上下文传递

### 2. 集成测试

- 测试HTTP中间件的完整流程
- 测试gRPC拦截器的完整流程
- 测试与业务逻辑的集成

## 性能优化

1. **Token缓存**：可以考虑对解析后的token进行缓存
2. **并发安全**：中间件设计为无状态，支持高并发
3. **错误日志**：记录认证失败的详细信息，便于问题排查

## 扩展性

1. **多认证方式**：可以扩展支持多种认证方式（如API Key、OAuth等）
2. **角色权限**：可以在中间件中添加角色和权限的验证
3. **审计日志**：可以添加用户操作的审计日志记录

## 总结

认证中间件的设计遵循了以下原则：

1. **单一职责**：专注于用户认证功能，不重复提供用户ID获取方法
2. **开闭原则**：支持扩展不同的认证方式
3. **依赖倒置**：依赖抽象接口而非具体实现
4. **接口隔离**：提供简洁的API接口
5. **避免重复**：复用`token.ParseRequest`方法，避免代码重复

通过这个中间件，我们实现了统一的用户认证机制，为后续的用户管理功能提供了坚实的基础。中间件专注于认证验证，而用户信息的获取则直接使用token包提供的功能，保持了代码的简洁性和一致性。
