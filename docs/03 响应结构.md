# 统一响应结构

本文档描述项目统一的 HTTP 响应结构与使用方式，基于 go-zero，并参考官方扩展用法（见 [HTTP 扩展](https://go-zero.dev/docs/tutorials/http/server/response/ext)）。

## 响应结构体

所有接口均返回以下结构：

```json
{
  "code": 0,
  "message": "response message",
  "data": any,
  "reason": any
}
```

- 成功：

```json
{
  "code": 0,
  "message": "ok",
  "data": {"...": "..."},
  "reason": ""
}
```

- 失败（示例：资源未找到）：

```json
{
  "code": 404001,
  "message": "Page not found.",
  "data": null,
  "reason": "错误信息或上下文"
}
```

- 参数校验失败：

```json
{
  "code": 400002,
  "message": "参数校验失败",
  "data": null,
  "reason": "字段 'Email' 验证失败: 邮箱格式不正确 (值: final-direct-testexample.com)"
}
```

## 封装位置

- 封装代码：`pkg/response/response.go`
- 响应结构：内部 `responseBody{ code, message, data, reason }`（不包含 HTTP 字段）
- 提供方法：
  - `response.SuccessCtx(ctx, w, message, data, reason)`
  - `response.FailCtx(ctx, w, code, message, reason)`
  - `response.WriteResponse(ctx, w, v)`（统一入口，兼容成功对象与 error）

## 在 handler 中的使用示例

推荐将 go-zero 生成的 `httpx.ErrorCtx/OkJsonCtx` 替换为统一入口：

```go
import (
    "github.com/clin211/miniblog-v3/pkg/response"
    "github.com/zeromicro/go-zero/rest/httpx"
)

func SomeHandler(svcCtx *svc.ServiceContext) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        var req types.SomeRequest
        if err := httpx.Parse(r, &req); err != nil {
            response.WriteResponse(r.Context(), w, err)
            return
        }

        l := logic.NewSomeLogic(r.Context(), svcCtx)
        resp, err := l.Do(&req)
        if err != nil {
            response.WriteResponse(r.Context(), w, err)
            return
        }

        response.WriteResponse(r.Context(), w, resp)
    }
}
```

如需自定义 message 或 reason，可使用 `SuccessCtx/FailCtx`：

```go
response.SuccessCtx(r.Context(), w, "response message", resp, "自定义备注")
response.FailCtx(r.Context(), w, 100001, "业务失败", "详细失败原因")
```

## 业务错误处理

使用 `errorx.Errno` 构造业务错误：

```go
err := &errorx.Errno{
    HTTP:    400,
    Code:    10001,
    Message: "用户不存在",
    Data:    nil,
    Reason:  "邮箱未注册",
}
response.WriteResponse(r.Context(), w, err)
```

## 预定义错误码

项目在 `pkg/errorx/code.go` 中预定义了常用错误：

```go
// 成功
OK = &Errno{HTTP: 200, Code: 0, Message: "Success.", Data: nil, Reason: ""}

// 系统错误
InternalServerError = &Errno{HTTP: 500, Code: 500001, Message: "Internal server error.", Data: nil, Reason: ""}

// 资源错误
ErrPageNotFound = &Errno{HTTP: 404, Code: 404001, Message: "Page not found.", Data: nil, Reason: ""}

// 参数错误
ErrBind = &Errno{HTTP: 400, Code: 400001, Message: "Error occurred while binding the request body to the struct.", Data: nil, Reason: ""}
ErrInvalidParameter = &Errno{HTTP: 400, Code: 400002, Message: "Parameter verification failed.", Data: nil, Reason: ""}

// 认证错误
ErrSignToken = &Errno{HTTP: 401, Code: 401001, Message: "Error occurred while signing the JSON web token.", Data: nil, Reason: ""}
ErrTokenInvalid = &Errno{HTTP: 401, Code: 401002, Message: "Token was invalid.", Data: nil, Reason: ""}
ErrUnauthorized = &Errno{HTTP: 401, Code: 401003, Message: "Unauthorized.", Data: nil, Reason: ""}
```

## 说明

- 统一入口 `WriteResponse` 会对以下类型进行特殊处理：
  - `*errorx.Errno`：按 `Errno.HTTP` 写入 HTTP 状态，业务结构取 `Code/Message/Data/Reason`
  - `validate.ValidationErrors` / `validate.ValidationErrorsWithCode`：HTTP 400，`code=400002`，`message="参数校验失败"`，`reason=错误详情`
  - 其他任意 `error`：HTTP 404，`code=404001`，`message="Page not found."`，`reason=err.Error()`
- 成功对象：HTTP 200，`code=0`，`message="ok"`，`data=对象内容`
- 设计优化：`pkg/response` 内部使用 `responseBody` 结构体，避免与 `errorx.Errno` 重复定义

## 示例

参考 `examples/` 目录下的示例：

- `examples/errorx_api/`：展示 API 层错误处理
- `examples/errorx_rpc/`：展示 RPC 网关错误处理
- `examples/response/`：展示各种响应方式
