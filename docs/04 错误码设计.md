# 错误码设计

## 设计目的

- 统一业务错误表达，提供可检索、可治理的业务错误码体系。
- 与现有 `pkg/response`、`pkg/validate` 保持一致：
  - 成功与参数校验失败依旧返回 `code=0`；
  - 资源未找到返回 `code=404001`，`message="Page not found."`；
  - 其他业务错误可按模块码段定义，便于横向扩展与排障。
- 遵循职责单一：
  - `errorx` 仅负责错误码定义、错误对象构造。
  - `response` 负责统一响应结构与写出 HTTP。
  - `validate` 负责参数校验与产生 `ValidationErrors`。

## 目录结构

```tree
pkg/errorx/
├── code.go       # 基础错误码常量定义
└── error.go      # Errno 类型与相关方法
```

## 核心设计

### Errno 结构体

```go
type Errno struct {
    HTTP    int         `json:"http"`    // HTTP 状态码
    Code    int         `json:"code"`    // 业务错误码
    Message string      `json:"message"` // 错误消息
    Reason  string      `json:"reason"`  // 错误原因
    Data    interface{} `json:"data"`    // 附加数据
}
```

### 预定义错误码

项目在 `pkg/errorx/code.go` 中预定义了常用错误码：

```go
// 成功
OK = &Errno{HTTP: 200, Code: 0, Message: "Success.", Data: nil, Reason: ""}

// 系统错误 (500xxx)
InternalServerError = &Errno{HTTP: 500, Code: 500001, Message: "Internal server error.", Data: nil, Reason: ""}

// 资源错误 (404xxx)
ErrPageNotFound = &Errno{HTTP: 404, Code: 404001, Message: "Page not found.", Data: nil, Reason: ""}

// 参数错误 (400xxx)
ErrBind = &Errno{HTTP: 400, Code: 400001, Message: "Error occurred while binding the request body to the struct.", Data: nil, Reason: ""}
ErrInvalidParameter = &Errno{HTTP: 400, Code: 400002, Message: "Parameter verification failed.", Data: nil, Reason: ""}

// 认证错误 (401xxx)
ErrSignToken = &Errno{HTTP: 401, Code: 401001, Message: "Error occurred while signing the JSON web token.", Data: nil, Reason: ""}
ErrTokenInvalid = &Errno{HTTP: 401, Code: 401002, Message: "Token was invalid.", Data: nil, Reason: ""}
ErrUnauthorized = &Errno{HTTP: 401, Code: 401003, Message: "Unauthorized.", Data: nil, Reason: ""}
```

### 错误码规范

- **0**: 成功
- **400xxx**: 客户端错误（参数错误、请求格式错误等）
- **401xxx**: 认证错误（未授权、Token 无效等）
- **404xxx**: 资源错误（页面未找到、资源不存在等）
- **500xxx**: 服务器错误（内部错误、系统异常等）
- **业务错误码**: 建议使用 100000+ 的码段，按模块划分

## 与 @response/、@validate/ 的衔接

- 保持文档（docs/03 响应结构.md）约定：
  - 成功：`code=0, message="ok", data=v, reason=""`；
  - 参数校验失败（`validate.ValidationErrors`）：`code=400002, message="参数校验失败", data=null, reason=错误详情`；
  - 其他 error：`code=404001, message="Page not found."`，`reason=err.Error()`；
  - `errorx.Errno`：按其 `Code/Message/Reason/Data` 渲染。

## 使用方式

### 1 在 logic 层返回业务错误

```go
import "github.com/clin211/miniblog-v3/pkg/errorx"

func (l *LoginLogic) verifyUser(email string) error {
    // 使用预定义错误
    if email == "" {
        return errorx.ErrInvalidParameter
    }
    
    // 构造自定义业务错误
    if !userExists(email) {
        return &errorx.Errno{
            HTTP:    404,
            Code:    10001,
            Message: "用户不存在",
            Data:    nil,
            Reason:  fmt.Sprintf("邮箱 %s 未注册", email),
        }
    }
    
    return nil
}

func (l *LoginLogic) Do(req *types.LoginRequest) (*types.LoginResponse, error) {
    if err := l.verifyUser(req.Email); err != nil {
        return nil, err
    }
    // ...
    return &types.LoginResponse{ /* ... */ }, nil
}
```

### 2 在 handler 层统一渲染

```go
import (
    "github.com/clin211/miniblog-v3/pkg/response"
    "github.com/zeromicro/go-zero/rest/httpx"
)

func LoginHandler(svcCtx *svc.ServiceContext) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        var req types.LoginRequest
        if err := httpx.Parse(r, &req); err != nil {
            // 参数校验失败 -> code=400002, message="参数校验失败"
            response.WriteResponse(r.Context(), w, err)
            return
        }

        l := logic.NewLoginLogic(r.Context(), svcCtx)
        resp, err := l.Do(&req)
        if err != nil {
            // 业务错误或其他错误 -> 交给 response 统一处理
            response.WriteResponse(r.Context(), w, err)
            return
        }

        response.WriteResponse(r.Context(), w, resp)
    }
}
```

### 3 直接使用预定义错误

```go
// 在业务逻辑中直接返回预定义错误
if token == "" {
    return errorx.ErrUnauthorized
}

if !isValidToken(token) {
    return errorx.ErrTokenInvalid
}

if resource == nil {
    return errorx.ErrPageNotFound
}
```

### 4 自定义错误消息

```go
// 使用 SetMessage 方法自定义错误消息
err := errorx.ErrInvalidParameter.SetMessage("邮箱格式不正确: %s", email)
return err
```

## 错误码扩展建议

### 业务模块错误码段

建议按以下方式分配业务错误码：

```go
// 用户模块 (100000-109999)
const (
    ErrUserNotFound     = 100001 // 用户不存在
    ErrUserDisabled     = 100002 // 用户被禁用
    ErrPasswordIncorrect = 100003 // 密码错误
)

// 文章模块 (110000-119999)
const (
    ErrArticleNotFound  = 110001 // 文章不存在
    ErrArticlePrivate   = 110002 // 文章私有
    ErrArticleDeleted   = 110003 // 文章已删除
)

// 评论模块 (120000-129999)
const (
    ErrCommentNotFound  = 120001 // 评论不存在
    ErrCommentSpam      = 120002 // 评论垃圾信息
)
```

### 构造业务错误

```go
// 方式1：直接构造
err := &errorx.Errno{
    HTTP:    400,
    Code:    100001,
    Message: "用户不存在",
    Data:    map[string]interface{}{"email": email},
    Reason:  "该邮箱未注册",
}

// 方式2：基于预定义错误修改
err := errorx.ErrInvalidParameter
err.Code = 100001
err.Message = "用户不存在"
err.Reason = "该邮箱未注册"
```

## 最佳实践

1. **统一错误处理**：在 handler 层使用 `response.WriteResponse` 统一处理所有错误
2. **预定义优先**：优先使用预定义的错误码，避免重复定义
3. **错误码规范**：按模块划分错误码段，便于管理和排查
4. **错误信息友好**：提供用户友好的错误消息和详细的错误原因
5. **错误数据丰富**：在 `Data` 字段中提供有助于调试的额外信息

## 示例

参考 `examples/` 目录下的示例：

- `examples/errorx_api/`：展示 API 层错误处理
- `examples/errorx_rpc/`：展示 RPC 网关错误处理
- `examples/response/`：展示各种响应方式
