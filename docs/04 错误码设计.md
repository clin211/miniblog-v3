## 设计目的

- 统一业务错误表达，提供可检索、可治理的业务错误码体系。
- 与现有 `pkg/response`、`pkg/validate` 保持一致：
  - 成功与参数校验失败依旧返回 `code=0`；
  - 资源未找到返回 `code=404`，`message="Not Found"`；
  - 其他业务错误可按模块码段定义，便于横向扩展与排障。
- 遵循职责单一：
  - `errorx` 仅负责错误码定义、错误对象、模块注册与渲染（不直接写 HTTP）。
  - `response` 负责统一响应结构与写出 HTTP。
  - `validate` 负责参数校验与产生 `ValidationErrors`。

## 目录结构（方案 B）

```tree
pkg/errorx/
├── code.go       # 基础 Code 常量与类型
├── error.go      # Error 类型与构造/包装
├── registry.go   # 模块注册与码段校验
├── renderer.go   # 将任意值渲染为 BaseResponse（不写 HTTP）
└── std.go        # 常见错误构造快捷函数
```

## 核心设计

- `type Code int`：业务码类型。预置常量 `0/400/401/403/404/409/429/500` 等，便于跨传输层映射。
- `type Error struct{ Code, Message, Reason, Cause, Meta }`：面向业务的错误对象，满足 `error`。
- `RegisterModule(module, Range{Start,End})`：注册模块码段，避免重复与越界。
- `NewModuleError(module, code, message, opts...)`：在模块内创建错误，编程期校验码段。
- `Render(v any) BaseResponse`：统一把成功值、`validate.ValidationErrors`、`errorx.Error`、其他 `error` 转为 `BaseResponse`。

## 与 @response/、@validate/ 的衔接

- 保持文档（docs/03 响应结构.md）约定：
  - 成功：`code=0, message="ok", data=v, reason=null`；
  - 参数校验失败（`validate.ValidationErrors`）：`code=0, message="参数校验失败", data=null, reason=[]string`；
  - 其他 error：示例沿用 Not Found：`code=404, message="Not Found"`，`reason=err.Error()`；
  - `errorx.Error`：按其 `Code/Message/Reason/Cause` 渲染。

## 使用方式

### 1) 在启动或模块初始化时注册码段

```go
import "github.com/clin211/miniblog-v3/pkg/errorx"

func init() {
    // 为 user 模块分配码段（示例：10000-19999）
    _ = errorx.RegisterModule("user", errorx.Range{Start: 10000, End: 19999})
}
```

### 2) 在 logic 层返回模块错误

```go
import "github.com/clin211/miniblog-v3/pkg/errorx"

func (l *LoginLogic) verifyUser(email string) error {
    // 10001: 用户不存在
    return errorx.NewModuleError("user", 10001, "用户不存在")
}

func (l *LoginLogic) Do(req *types.LoginRequest) (*types.LoginResponse, error) {
    if err := l.verifyUser(req.Email); err != nil {
        return nil, err
    }
    // ...
    return &types.LoginResponse{ /* ... */ }, nil
}
```

### 3) 在 handler 层统一渲染

```go
import (
    "github.com/clin211/miniblog-v3/pkg/errorx"
    "github.com/clin211/miniblog-v3/pkg/response"
    "github.com/zeromicro/go-zero/rest/httpx"
)

func LoginHandler(svcCtx *svc.ServiceContext) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        var req types.LoginRequest
        if err := httpx.Parse(r, &req); err != nil {
            // 参数校验失败 -> code=0, message="参数校验失败"
            resp := errorx.Render(err)
            httpx.OkJsonCtx(r.Context(), w, resp)
            return
        }

        l := logic.NewLoginLogic(r.Context(), svcCtx)
        resp, err := l.Do(&req)
        if err != nil {
            // 模块错误或其他错误 -> 交给 errorx 渲染
            httpx.OkJsonCtx(r.Context(), w, errorx.Render(err))
            return
        }

        httpx.OkJsonCtx(r.Context(), w, errorx.Render(resp))
    }
}
```

### 4) 与现有 `response` 兼容调用

如果你仍需自定义 message 或 reason，可继续使用：

```go
response.SuccessCtx(ctx, w, "ok", data, nil)
response.FailCtx(ctx, w, 404, "Not Found", "user id not found")
```

而统一入口可改为：

```go
httpx.OkJsonCtx(ctx, w, errorx.Render(v))
```

## 进阶建议

- 统一在 `apps/*/internal/handler/routes.go` 的初始化处完成模块注册，避免遗漏。
- 约定每个模块内的错误码段用途，例如：
  - `10xxx` 用户模块：`10001 用户不存在`、`10002 密码错误`、`10003 用户被禁用`；
  - `20xxx` 文章模块：`20001 文章不存在`、`20002 无权访问` 等。
- 后续如需多语言或导出错误码清单，可在此基础上演进到配置驱动（方案 C），由 `go:generate` 生成常量与 Markdown 文档。
